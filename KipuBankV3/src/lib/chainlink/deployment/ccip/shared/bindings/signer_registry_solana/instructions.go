// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package signer_registry_solana

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
// Accepts the ownership transfer as the proposed new owner. //  // This instruction completes the two-step ownership transfer process. It must be called // by the account that was previously proposed as the new owner through the `propose_new_owner` // instruction. Once executed, the proposed owner becomes the new program owner with full // authority to manage signers and configuration. //  // # Parameters //  // * `ctx` - The context containing all accounts required for accepting ownership: // - `authority`: Must be the account that was proposed as the new owner in the Config. // - `config`: The mutable Config account that will be updated with the new owner. //  // # Returns //  // Returns `Ok(())` when ownership is successfully transferred. //  // # Errors //  // * `InvalidProposedOwner` - The authority is not the currently proposed owner, or // no owner has been proposed.
func NewAcceptOwnershipInstruction(
	authorityAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 2 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_signer" instruction.
// This instruction allows the program owner (configured in the `owner` field of the Config // PDA) to add a new signer to the authorized signers list. //  // # Parameters //  // * `ctx` - The context containing all accounts required for adding a signer: // - `authority`: Must be the current program owner as stored in the Config account. // - `config`: The Config account to verify owner authorization. // - `signers`: The mutable Signers account where the new signer will be added. //  // * `signer_evm_address` - A 20-byte array representing the EVM address of the new signer. // Must not be the zero address ([0; 20]). //  // # Returns //  // Returns `Ok(())` when the signer is successfully added to the list. //  // # Errors //  // * `Unauthorized` - The authority is not the current program owner. // * `TooManySigners` - The signers list has reached its maximum capacity of 20 signers. // * `InvalidSigner` - The provided EVM address is the zero address ([0; 20]). // * `DuplicateSigner` - The provided EVM address already exists in the signers list // (either as a primary address or as a new address in key rotation).
func NewAddSignerInstruction(
	// Params:
	signerEvmAddressParam [20]uint8,

	// Accounts:
	authorityAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	signersAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddSigner[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `signerEvmAddressParam`:
		err = enc__.Encode(signerEvmAddressParam)
		if err != nil {
			return nil, errors.NewField("signerEvmAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "signers": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signersAccount, true, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Initializes the CCIP Signer Registry program with initial configuration and owner. //  // This instruction must be called once after program deployment to set up the program's // state accounts. It creates both the Config and Signers accounts with their respective // Program Derived Addresses (PDAs). The authority account signing this transaction will // be set as the program owner. //  // # Parameters //  // * `ctx` - The context containing all accounts required for initialization: // - `authority`: The signer who is deploying/initializing the program. This account will // become the program owner with exclusive authority to manage signers and propose // ownership transfers. When the `init_guard` feature is enabled, this must be the // program's upgrade authority. // - `system_program`: The Solana system program for account creation. // - `config`: The Config PDA that will store the program owner and proposed owner. // - `signers`: The Signers PDA that will store the list of authorized CCIP signers. // - `program` (optional): The program account itself (when `init_guard` feature is enabled). // - `program_data` (optional): The program data account (when `init_guard` feature is enabled). //  // # Returns //  // Returns `Ok(())` on successful initialization. //  // # Errors //  // * `InvalidInitializer` - When `init_guard` feature is enabled and the authority is not // the program's upgrade authority.
func NewInitializeInstruction(
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	signersAccount solanago.PublicKey,
	programForVerificationAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 1 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 2 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 3 "signers": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signersAccount, true, false))
		// Account 4 "program_for_verification": Read-only, Non-signer, Required, Address: S1GN4jus9XzKVVnoHqfkjo1GN8bX46gjXZQwsdGBPHE
		accounts__.Append(solanago.NewAccountMeta(programForVerificationAccount, false, false))
		// Account 5 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
		// Account 6 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 7 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "promote_signer_address" instruction.
// This instruction allows the program owner (configured in the `owner` field of the Config // PDA) to complete the key rotation by promoting the new address to become the primary address. //  // This instruction finalizes the blue/green key rotation process by replacing the old address // with the new address that was previously set. After this operation, only the new address // will be valid for the signer, and the old address will no longer be accepted. //  // This should only be called after ensuring that all in-flight messages signed with the old // key have been processed, as the old address will no longer be valid after rotation. //  // # Parameters //  // * `ctx` - The context containing all accounts required for rotating the address: // - `authority`: Must be the current program owner as stored in the Config account. // - `config`: The Config account to verify owner authorization. // - `signers`: The mutable Signers account where the address rotation will occur. //  // * `signer_evm_address` - A 20-byte array representing the EVM address to promote. // This can be either the current primary (blue) address or the new (green) address // of the signer whose key rotation should be completed. The signer's new address // will become the primary address after this operation. //  // # Returns //  // Returns `Ok(())` when the address rotation is successfully completed. //  // # Errors //  // * `Unauthorized` - The authority is not the current program owner. // * `NoMatchingSignerFound` - The specified EVM address does not exist in the signers list // (neither as a primary address nor as a new address). // * `MissingNewAddress` - The signer does not have a new address set for rotation. // You must call `set_signer_new_address` before attempting to promote.
func NewPromoteSignerAddressInstruction(
	// Params:
	signerEvmAddressParam [20]uint8,

	// Accounts:
	authorityAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	signersAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PromoteSignerAddress[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `signerEvmAddressParam`:
		err = enc__.Encode(signerEvmAddressParam)
		if err != nil {
			return nil, errors.NewField("signerEvmAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "signers": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signersAccount, true, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "propose_new_owner" instruction.
// Proposes a new owner for the CCIP Signer Registry program ownership transfer. //  // This instruction initiates a two-step ownership transfer process. The current owner // proposes a new owner, who must then explicitly accept the ownership using the // `accept_ownership` instruction. This two-step process prevents accidental transfers // and ensures the new owner is ready to assume responsibilities. //  // # Parameters //  // * `ctx` - The context containing all accounts required for proposing a new owner: // - `authority`: Must be the current program owner as stored in the Config account. // - `config`: The mutable Config account where the proposed owner will be stored. //  // * `new_owner` - The public key of the proposed new owner. This account will need to // call `accept_ownership` to complete the transfer. The proposed owner can be changed // by calling this instruction again before acceptance. //  // # Returns //  // Returns `Ok(())` when the new owner is successfully proposed. //  // # Errors //  // * `Unauthorized` - The authority is not the current program owner.
func NewProposeNewOwnerInstruction(
	// Params:
	newOwnerParam solanago.PublicKey,

	// Accounts:
	authorityAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ProposeNewOwner[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newOwnerParam`:
		err = enc__.Encode(newOwnerParam)
		if err != nil {
			return nil, errors.NewField("newOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 2 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_signer" instruction.
// This instruction allows the program owner (configured in the `owner` field of the Config // PDA) to remove a signer from the authorized signers list. //  // # Parameters //  // * `ctx` - The context containing all accounts required for removing a signer: // - `authority`: Must be the current program owner as stored in the Config account. // - `config`: The Config account to verify owner authorization. // - `signers`: The mutable Signers account from which the signer will be removed. //  // * `signer_evm_address` - A 20-byte array representing the EVM address of the signer to remove. // This can match either a primary address or a new address that was set for rotation. //  // # Returns //  // Returns `Ok(())` when the signer is successfully removed from the list. //  // # Errors //  // * `Unauthorized` - The authority is not the current program owner. // * `NoMatchingSignerFound` - The specified EVM address does not exist in the signers list // (neither as a primary address nor as a new address in rotation).
func NewRemoveSignerInstruction(
	// Params:
	signerEvmAddressParam [20]uint8,

	// Accounts:
	authorityAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	signersAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveSigner[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `signerEvmAddressParam`:
		err = enc__.Encode(signerEvmAddressParam)
		if err != nil {
			return nil, errors.NewField("signerEvmAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "signers": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signersAccount, true, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_signer_new_address" instruction.
// This instruction allows the program owner (configured in the `owner` field of the Config // PDA) to set a new address for a signer to enable blue/green key rotation. //  // This instruction initiates a key rotation process for a signer by setting a new EVM address // while keeping the old address active. This implements a blue/green deployment pattern where // both addresses remain valid during the transition period. Off-chain, the signer will start // exclusively signing with the new key, but on-chain, signatures from both addresses are // accepted until the rotation is completed. //  // **Important Note on Key Re-use**: The registry allows rotating a signer back to a previously // used address. For example, an address retired at time t10 can be reinstated at time t100. // The SignerRegistry itself does not prevent key re-use. Consuming applications must account // for this behavior to prevent potential issues such as historic signatures being treated as // valid again. //  // # Parameters //  // * `ctx` - The context containing all accounts required for setting a new address: // - `authority`: Must be the current program owner as stored in the Config account. // - `config`: The Config account to verify owner authorization. // - `signers`: The mutable Signers account where the new address will be set. //  // * `signer_evm_address` - A 20-byte array representing the EVM address of the signer // that needs key rotation. This can match either an existing primary address or a // previously set new address (green address) in the list. //  // * `signer_new_evm_address` - A 20-byte array representing the new EVM address that will // replace the old address after rotation is complete. This address must not already exist // in the signers list. If this is the zero address ([0; 20]), the new EVM address will be // cleared. //  // # Returns //  // Returns `Ok(())` when the new address is successfully set for the signer. This is idempotent, // so it will return `Ok(())` even if the operation is a NOOP. //  // # Errors //  // * `Unauthorized` - The authority is not the current program owner. // * `NoMatchingSignerFound` - The signer EVM address does not exist in the signers list // (neither as a primary address nor as a new address). // * `DuplicateSigner` - The new EVM address already exists in the signers list // (either as a primary address or as another signer's new address).
func NewSetSignerNewAddressInstruction(
	// Params:
	signerEvmAddressParam [20]uint8,
	signerNewEvmAddressParam [20]uint8,

	// Accounts:
	authorityAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	signersAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetSignerNewAddress[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `signerEvmAddressParam`:
		err = enc__.Encode(signerEvmAddressParam)
		if err != nil {
			return nil, errors.NewField("signerEvmAddressParam", err)
		}
		// Serialize `signerNewEvmAddressParam`:
		err = enc__.Encode(signerNewEvmAddressParam)
		if err != nil {
			return nil, errors.NewField("signerNewEvmAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "signers": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signersAccount, true, false))
		// Account 3 "event_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
